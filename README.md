# Rhythm Game (이름 미정)

## 조원
- 이종민
- 조주안
- 윤영우
- 나경수

## 게임 방식
본 게임은 테트리스에 많은 영향을 받은 게임이다.
테트리스에 미노가 있듯이, 이 게임에는 Knot(임시 명칭)이 있다.

### Knot
Knot의 구성 요소는 다음과 같다.
- 리듬
- 어떤 키로 입력해야 하는지

예를 들면 다음과 같다: '4연타'의 리듬을 '트릴'(두 키를 번갈아서)로 연주하라!
자세한 부분은 하단 '구현' 항목에서 설명한다.

### Deck과 Next
이 게임은 Hold가 없지만, 사실은 더 강한 기능을 지원한다. 이는 테트리스처럼 현재 내려오는 하나를 쳐야 하는 것이 아니라, 덱에 있는 것 중 하나를 골라서 치는 방식이라는 뜻이다. 덱의 크기는 현재 3개로 맞추어져 있는데, 이는 홀드가 두 개 있는 것과 유사한 효과를 준다.

Next의 경우 테트리스와 동일하게 5개 보여준다.

### Knot 처리법
Knot를 어떻게 처리해야 하는지는 간단하다.
박자에 맞게 해당 Knot를 치는 것이 전부이다.
여기서 '박자에 맞게'는 '그리드에 맞게'를 의미해서, 현재는 한 박을 24개로 나눈 그리드 기준으로 맞는 리듬을 쳐서 처리할 수 있다.
키도 Knot에 지정된 대로 맞게 입력해야 하나, 이는 아직 미구현이어서 현재 버전에서는 리듬만 인식이 된다.

이때, '4연타'라는 리듬은 4연타를 빠르게 하든, 느리게 하든 자유롭다. 어느 타이밍에 시작하는지도 자유롭다. 단, 리듬의 길이는 어느 정도 제한이 되어 있다. 너무 느리게 칠 수 없으며, 그리드 간격보다 빠르게 칠 수 없다.
이 자유도에 걸맞게 구현 난이도도 올라간 탓에, 총 300여줄의 짧은 코드를 짜는 데 며칠이나 소요되게 되었다.

### 판정과 콤보
판정은 Perfect, Good, Okay의 세 등급으로 나누어져 있다. 현재 판정 방식은 내가 친 리듬이 Knot의 리듬의 각 음으로부터 '길이의 몇 %' 떨어졌는가를 기준으로 분류되나, 후에 테스트한 결과 빠른 리듬을 칠 때 판정을 내기가 상당히 어려워서 어느정도 보완할 필요가 있어 보인다. (보완 코드 난이도가 높지는 않을 것으로 예상된다)
콤보는 Perfect로 칠 경우 계속 Perfect로 이어지다가, 만약 어떤 입력이 어떤 Knot도 Perfect로 처리할 수 없다고 계산되면(즉, Perfect로 더 잇지 못하는 입력이 발생하면) 판정 등급을 낮춰 Good 콤보로 이어지게 된다. 물론, Good으로도 해당 입력을 처리할 수 없으면 판정을 더 낮추고, 아예 어떤 판정으로도 덱의 Knot을 처리할 수 없으면 콤보가 끊어지게 된다. 끊어진 콤보는 초기화되어 이후 들어오는 입력부터 다시 시작한다.


### 기타 게임 요소(미구현)
아래는 게임 로직 면에서 추가되어야 할/추가할 만한 부분이다.
- Knot 처리에 입력 키도 반영(위에서 언급하기도 함)
- 왼손/오른손 분리해서 처리 & 2인 게임으로의 확장(구현 방식은 유사할 것 같음, 다만 후자는 HP 등 처리할 부분이 조금 더 있음)
- 왼손 & 오른손 연계 패턴(폴리 리듬 등), 특정 그루브 연주 등에 따른 보너스

## 그래픽
해당 단락은 본 게임의 그래픽이 어떤 형태로 만들어져야 할 것인지에 대한 틀에 해당하며, 게임 로직 개발 역할을 맡는 경우 건너뛰어도 좋다.
또, 아래 내용은 개인적인 의견이며 추천 사항이기에, 개발자 본인이 판단하기에 더 가독성 좋거나 멋진 연출이 가능할 것 같다고 생각하면 얼마든지 바꾸어도 좋다.

덱은 위, Next는 오른쪽에 테트리스 느낌이 나게 배치한다.
가운데 부분에는 사용자의 입력이 찍히는 부분이 있다. 이는 가로 평행선 모양으로 되어있어, 한 마디가 지나갈 때마다 한 칸씩 위로 올라간다.
입력이 특정 knot를 만족하면 knot를 구성하는 입력들에 해당 Knot를 표기해준다. (예를 들어, 색 있는 네모 상자로 씌운다던지)

## 구현
본 단락은 첫 단락에서 설명한 게임 방식이 어떻게 구현되었는지에 대해 설명한다. 그래픽 개발을 하는 경우 읽지 않아도 좋다.

클래스는 Rhythm, Knot, Rope, Map의 네 개만 사용하였고, 객체지향적으로 복잡한 구조는 아니다.
### Rhythm과 Knot
해당 클래스는 본 게임에서 사용할 Knot를 지정해준다. 테트리스에서 게임에 사용할 미노를 지정해주는 것과 같다.
따라서, 본 클래스의 인스턴스는 불변한다고 생각하면 된다.
리듬은 코드에서도 쉽게 확인할 수 있지만, ratio와 가능한 길이에 대한 정보를 담고 있다.
ratio는 리듬을 구성하는 음의 간격 비를 의미하며, 1 : 1 : 1이나 2 : 1의 경우 각각 (1, 1, 1)과 (2, 1)로 저장된다.
가능한 길이는 ratio에서 1에 해당하는 것이 실제 얼마의 길이를 가질 수 있는지를 알려주며, 이 길이는 그리드에서의 길이다. 즉, 길이가 4면 4/24, 즉 1/6마디라는 뜻이다.
Knot는 여기에 키 입력에 대한 정보와 accept 우선도를 제공한다. 전자는 아직 미구현이어서 사용하지 않은 정보이며, 후자는 뒤에 설명한다.

### 구현 아이디어
어떻게 하면 아무렇게나 들어오는 입력이 어떤 리듬인지 확인할 수 있을까? 여기서는 가장 단순하고 확실한 방법을 사용하였다.
입력이 들어오면, 해당 입력으로 시작할 수 있는 모든 Knot를 처리할 수 있는 '경우의 수'를 만들어준다. 이 각각의 경우의 수가 Rope이다.
이 Rope는 다음 입력이 들어와야 하는 시간 구간을 만들고, 해당 구간을 지나친다면 실패한 것이므로 제거되며, 해당 구간에 입력이 들어온다면 그 다음 입력이 들어와야 할 시간 구간을 다시 만든다.
그러다 보면 입력이 정확히 들어와서 해당 리듬을 쳤다고 인식되는 순간이 오는데, 거기서 우선순위에 따라 accept를 결정하고, 이에 따라 뒷처리를 한다.

이는 매우 추상적으로 설명한 것으로, 마지막 부분에서 다시 전체 흐름을 정리해 설명한다.

### Rope
Rope는 다시 설명하면, 덱에 있는 Knot를 처리할 수 있는 각각의 '경우의 수'에 해당하는 객체이다. 이 경우의 수는, '그리드의 어떤 위치에서' 시작해서, '어떤 Knot를' '어떤 길이로', '어떤 정확도로' 칠 수 있는 경우의 수를 의미하며, 본 문장에서 작은 따옴표 친 부분에 각각 해당하는 변수를 갖고 있다. Rope는 다음 입력이 언제 들어와야 하는지를 알려주는 interval 프로퍼티와, 해당 구간에 입력이 들어온 경우를 처리하는 apply 메서드, 그리고 해당 경우의 수대로 이루어졌는지를 확인하는 is_complete 메서드만 가지는 단순한 클래스이다.

### Map
Map은 간단하게, '한 사람의 게임 플레이를 처리하는 객체'이다. 다만, 왼손과 오른손을 분리하는 경우 둘을 독립적으로 처리할 것이라면 다른 Map 객체를 써야 할 수도 있다.
Map은 deck과 next를 관리하고, 현재의 콤보 판정(rating)과 콤보 개수, 그리고 탐색 중인 경우의 수(alive), 현재 시간이 구간에 해당하는 경우의 수(open), 이를 작성할 때 필요한 타임라인(timeline)을 추적한다.
메서드에 대한 설명은 라이프사이클에 통합하여 한다.

### 전체 라이프사이클
main.py의 루프를 보면 알 수 있지만, 전체 구조는 다음과 같다.
매 프레임마다 시간이 측정되고, 해당 시간의 정보를 넘겨 Map의 update 메서드가 수행된다.
update 메서드는 작성된 타임라인으로부터 open을 작성하며, 콤보가 끊어지는지 확인한다.
만약 입력이 들어온다면, apply 메서드가 실행되는데, apply 메서드는 몇 단계로 나누어져 있다.
우선, open에 있는 Rope는 올바른 타이밍에 입력이 들어온 것이므로 Rope의 apply 메서드를 실행시켜 준다.
그 가운데 완성된 Rope가 있을 수 있는데, 이들 중 판정이 좋은 것, 또 우선순위가 높은 것부터 하여 덱에 있는 특정 Knot의 개수를 초과하지 않도록 Rope를 선별한다. 이 선별한 것이 accepted 목록이다.
예를 들어, 덱이 [1, 2, 2]이고 완성된 Rope가 우선순위대로 [3a, 2a, 2b, 1a, 2c]면, accepted는 [2a, 2b, 1a]가 된다.
accepted에 대한 처리는 나중에 하고, alive를 다시 작성한다. 이것은 하나, 덱이 바뀐 경우 덱에서 사라진 knot에 해당하는 Rope를 제거하는 것이고(쓰면서 알았는데, 이러면 accepted 처리 후 덱에서 지워지는 걸 반영하지 못한다. 이것도 수정해야 할 것 같다), 둘, 새로 들어온 입력으로 시작하는 Rope를 추가하는 것이다.
그 다음 accepted의 처리를 한다. 현재 콤보 레이팅과 같거나 더 좋은 레이팅의 accepted는 바로 반영이 되어 덱의 해당 Knot를 Next에서 가져오며, Next에는 새로 하나를 뽑게 한다. 그렇지 않은 경우 기록만 해 두고 추후 콤보 레이팅이 떨어졌을 때 "이 콤보로는 이었어!"라는 걸 알려줄 때 사용한다. 다만, 이 문서를 작성하던 도중 그 부분 처리를 빼먹었다는 것을 깨달아서, 아마 빠르게 고치려고 노력할 것 같다.
그리고 새로 작성된 alive를 바탕으로 타임라인을 새로 작성하고, open을 비워주면(이걸 빼먹어서 한두 시간은 더 쓴 듯 하다) 입력이 들어올 때의 처리가 끝난다.
콤보 처리 방식은 당장 코드에 실수가 있어서 고친 후에 작성할 예정이다.
